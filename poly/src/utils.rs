use crate::mle::DenseMultilinearExtension;
use ark_std::cfg_iter_mut;
use crypto_primitives_algebra::PrimeField;
#[cfg(feature = "parallel")]
use rayon::iter::{IndexedParallelIterator, IntoParallelRefMutIterator, ParallelIterator};
use thiserror::Error;

/// A `enum` specifying the possible failure modes of the arithmetics.
#[derive(displaydoc::Display, Debug, Error)]
pub enum ArithErrors {
    /// Invalid parameters: {0}
    InvalidParameters(String),
}

#[macro_export]
macro_rules! neg {
    ($a:expr) => {
        neg!($a, "Negation overflow")
    };
    ($a:expr, $msg:expr) => {
        $a.checked_neg().expect($msg)
    };
}

#[macro_export]
macro_rules! add {
    ($a:expr, $b:expr) => {
        add!($a, $b, "Addition overflow")
    };
    ($a:expr, $b:expr, $msg:expr) => {
        $a.checked_add($b).expect($msg)
    };
}

#[macro_export]
macro_rules! sub {
    ($a:expr, $b:expr) => {
        sub!($a, $b, "Subtraction overflow")
    };
    ($a:expr, $b:expr, $msg:expr) => {
        $a.checked_sub($b).expect($msg)
    };
}

#[macro_export]
macro_rules! mul {
    ($a:expr, $b:expr) => {
        mul!($a, $b, "Multiplication overflow")
    };
    ($a:expr, $b:expr, $msg:expr) => {
        $a.checked_mul($b).expect($msg)
    };
}

#[macro_export]
macro_rules! div {
    ($a:expr, $b:expr) => {
        div!($a, $b, "Division by zero")
    };
    ($a:expr, $b:expr, $msg:expr) => {
        $a.checked_div($b).expect($msg)
    };
}

#[macro_export]
macro_rules! rem {
    ($a:expr, $b:expr) => {
        rem!($a, $b, "Division by zero")
    };
    ($a:expr, $b:expr, $msg:expr) => {
        $a.checked_rem($b).expect($msg)
    };
}

#[macro_export]
macro_rules! ilog_round_up {
    ($a:expr, $tp: ty) => {{
        let res = if $a.is_power_of_two() {
            $a.ilog2()
        } else {
            add!($a.ilog2(), 1)
        };
        <$tp>::try_from(res).expect(concat!("ilog doesn't fit ", stringify!($tp)))
    }};
}

/// This function build the eq(x, r) polynomial for any given r.
///
/// Evaluate
///      eq(x,y) = \prod_i=1^num_var (x_i * y_i + (1-x_i)*(1-y_i))
/// over r, which is
///      eq(x,y) = \prod_i=1^num_var (x_i * r_i + (1-x_i)*(1-r_i))
pub fn build_eq_x_r<F>(
    r: &[F],
    cfg: &F::Config,
) -> Result<DenseMultilinearExtension<F>, ArithErrors>
where
    F: PrimeField,
{
    let evals = build_eq_x_r_vec(r, cfg)?;
    let mle =
        DenseMultilinearExtension::from_evaluations_vec(r.len(), evals, F::zero_with_cfg(cfg));

    Ok(mle)
}

/// This function build the eq(x, r) polynomial for any given r, and output the
/// evaluation of eq(x, r) in its vector form.
///
/// Evaluate
///      eq(x,y) = \prod_i=1^num_var (x_i * y_i + (1-x_i)*(1-y_i))
/// over r, which is
///      eq(x,y) = \prod_i=1^num_var (x_i * r_i + (1-x_i)*(1-r_i))
pub fn build_eq_x_r_vec<F>(r: &[F], cfg: &F::Config) -> Result<Vec<F>, ArithErrors>
where
    F: PrimeField,
{
    // we build eq(x,r) from its evaluations
    // we want to evaluate eq(x,r) over x \in {0, 1}^num_vars
    // for example, with num_vars = 4, x is a binary vector of 4, then
    //  0 0 0 0 -> (1-r0)   * (1-r1)    * (1-r2)    * (1-r3)
    //  1 0 0 0 -> r0       * (1-r1)    * (1-r2)    * (1-r3)
    //  0 1 0 0 -> (1-r0)   * r1        * (1-r2)    * (1-r3)
    //  1 1 0 0 -> r0       * r1        * (1-r2)    * (1-r3)
    //  ....
    //  1 1 1 1 -> r0       * r1        * r2        * r3
    // we will need 2^num_var evaluations

    let mut eval = Vec::new();
    build_eq_x_r_helper(r, &mut eval, cfg)?;

    Ok(eval)
}

/// A helper function to build eq(x, r) recursively.
/// This function takes `r.len()` steps, and for each step it requires a maximum
/// `r.len()-1` multiplications.
fn build_eq_x_r_helper<F>(r: &[F], buf: &mut Vec<F>, cfg: &F::Config) -> Result<(), ArithErrors>
where
    F: PrimeField,
{
    if r.is_empty() {
        return Err(ArithErrors::InvalidParameters("r length is 0".into()));
    } else if r.len() == 1 {
        // initializing the buffer with [1-r_0, r_0]
        buf.push(F::one_with_cfg(cfg) - &r[0]);
        buf.push(r[0].clone());
    } else {
        build_eq_x_r_helper(&r[1..], buf, cfg)?;

        // suppose at the previous step we received [b_1, ..., b_k]
        // for the current step we will need
        // if x_0 = 0:   (1-r0) * [b_1, ..., b_k]
        // if x_0 = 1:   r0 * [b_1, ..., b_k]
        // let mut res = vec![];
        // for &b_i in buf.iter() {
        //     let tmp = r[0] * b_i;
        //     res.push(b_i - tmp);
        //     res.push(tmp);
        // }
        // *buf = res;

        let mut res = vec![F::zero_with_cfg(cfg); buf.len() << 1];
        cfg_iter_mut!(res).enumerate().for_each(|(i, val)| {
            let bi = buf[i >> 1].clone();
            let tmp = r[0].clone() * &bi;
            if (i & 1) == 0 {
                *val = bi - tmp;
            } else {
                *val = tmp;
            }
        });
        *buf = res;
    }

    Ok(())
}
